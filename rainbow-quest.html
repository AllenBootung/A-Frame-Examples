<!DOCTYPE html>
<html>

<head>
    <title>Rainbow Quest (work in progress)</title>
    <meta name="description" content="Rainbow Quest (work in progress)">
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="js/aframe-environment-component.js"></script>
    <script src="js/controller-listener.js"></script>
    <script src="js/player-move.js"></script>
    <script src="js/raycaster-extras.js"></script>
    <script src="js/rainbow-quest.js"></script>
</head>

<body>

<script>
// if raycaster is pointing at this object, press trigger to change color
AFRAME.registerComponent("rainbow-quest", {
    init: function () 
    {
        this.rainbowQuest = new RainbowQuest();        
        this.rainbowQuest.generateDungeon();

        let test = this.rainbowQuest.getCellWithType();
        while (test == null)
        {
            console.log("Unsolvable dungeon created, restarting...");
            this.rainbowQuest.reset();
            this.rainbowQuest.generateDungeon();
            test = this.rainbowQuest.getCellWithType();
        }


        // merge geometries to reduce number of draw calls and save FPS
        // (x,y,z): min corner of the box
        function createBoxGeom(x,y,z, w,h,d)
        {
            let boxGeom = new THREE.BoxGeometry(w, h, d);
            boxGeom.translate(x + w/2, y + h/2, z + d/2);
            return boxGeom;
        }

        // floor
        function createPlaneGeom(x,y,z, w,h,d)
        {
            let planeGeom = new THREE.PlaneGeometry(w, d);
            planeGeom.rotateX(-Math.PI/2);
            planeGeom.translate(x + w/2, y + h/2, z + d/2);
            return planeGeom;
        }

        function createHorizWallPlaneGeom(x,y,z, w,h)
        {
            let planeGeom = new THREE.PlaneGeometry(w, h);
            planeGeom.translate(x + w/2, y + h/2, z);
            return planeGeom;
        }

        function createVertWallPlaneGeom(x,y,z, w,h)
        {
            let planeGeom = new THREE.PlaneGeometry(w, h);
            planeGeom.rotateY(-Math.PI/2);
            planeGeom.translate(x, y + h/2, z + w/2);
            return planeGeom;
        }

        // walls

        let wallGeomArray = [];
        let wallHeight = 2;
        let wallThick = 0.02;

        // change wall sizes to prevent overlap, and also prevent gaps between walls

        for (let i = 0; i < this.rainbowQuest.numCellHoriz; i++)
            for (let j = 0; j < this.rainbowQuest.numCellVert+1; j++)
                if (this.rainbowQuest.horizWallArray[i][j].visible)
                {
                    console.log()
                    wallGeomArray.push( createHorizWallPlaneGeom(i, 0, j, 1, wallHeight) );
                }
                    // wallGeomArray.push( createBoxGeom(i, 0, j, 1, wallHeight, wallThick) );

        for (let i = 0; i < this.rainbowQuest.numCellHoriz+1; i++)
            for (let j = 0; j < this.rainbowQuest.numCellVert; j++)
                if (this.rainbowQuest.vertWallArray[i][j].visible)
                {
                    console.log()
                    wallGeomArray.push( createVertWallPlaneGeom(i, 0, j, 1, wallHeight) );
                }
                /*
                {
                    if (i < this.rainbowQuest.numCellHoriz && this.rainbowQuest.horizWallArray[i][j].visible)
                        wallGeomArray.push( createBoxGeom(i, 0, j + wallThick, wallThick, wallHeight, 1 - wallThick) );
                    else
                        wallGeomArray.push( createBoxGeom(i, 0, j, wallThick, wallHeight, 1) );
                }
                */

        let wallGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries( wallGeomArray );

        let loader = new THREE.TextureLoader();
        let wallDiffuse = loader.load("images/stone-wall-diffuse-256.jpg");
        wallDiffuse.repeat.set(2,3);
        wallDiffuse.wrapS = THREE.RepeatWrapping;
        wallDiffuse.wrapT = THREE.RepeatWrapping;
        let wallNormal = loader.load("images/stone-wall-normal-256.jpg");
        wallNormal.repeat.set(2,3);
        wallNormal.wrapS = THREE.RepeatWrapping;
        wallNormal.wrapT = THREE.RepeatWrapping;
        let wallMaterial = new THREE.MeshStandardMaterial({color: "#FFFFFF", map:wallDiffuse, normalMap:wallNormal, side:THREE.DoubleSide});

        let wall = new THREE.Mesh(wallGeometry, wallMaterial);
        let wallElement = document.getElementById("wallEntity");
        wallElement.setObject3D( "mesh", wall );

        // path and solid region tiles

        let pathGeomArray = [];
        // let solidGeomArray = [];

        for (let i = 0; i < this.rainbowQuest.numCellHoriz; i++)
            for (let j = 0; j < this.rainbowQuest.numCellVert; j++)
            {
                let cell = this.rainbowQuest.cellArray[i][j];
                
                // color rooms separately later
                if (cell.type == Cell.ROOM)
                    continue;

                // create a "tile" at the bottom of this location
                if (cell.type == Cell.PATH) 
                    pathGeomArray.push( createPlaneGeom(i, 0, j, 1, 0, 1) );
                    // pathGeomArray.push( createBoxGeom(i, 0, j, 1, 0.02, 1) );

                /*
                if (cell.type == Cell.SOLID)
                    solidGeomArray.push( createBoxGeom(i, 0, j, 1, 0.02, 1) );
                */
            }

        if (pathGeomArray.length == 0)
            console.log("ERROR, NEED TO REDO generateDungeon because there are NO PATHS")

        let pathGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries( pathGeomArray );

        let pathDiffuse = loader.load("images/floor-diffuse-256.jpg");
        let pathNormal = loader.load("images/floor-normal-256.jpg");
        let pathMaterial = new THREE.MeshStandardMaterial({color: "#FFFFFF", map:pathDiffuse, normalMap:pathNormal});

        let path = new THREE.Mesh(pathGeometry, pathMaterial);
        let pathElement = document.getElementById("pathEntity");
        pathElement.setObject3D( "mesh", path );

        /*
        // Let's save some triangles and not include these...
        let solidGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries( solidGeomArray );
        let solidMaterial = new THREE.MeshLambertMaterial({color: "#000000"});
        let solid = new THREE.Mesh(solidGeometry, solidMaterial);
        let solidElement = document.getElementById("solidEntity");
        solidElement.setObject3D( "mesh", solid );
        */

        // start
        // orb 1 2 3 4 5 6
        // fire fire ice ice goal goal goal
        let roomColorArray = [
          "#CCCCCC", 
          "#FFCCCC", "#FFCC88", "#FFFF88", "#99FF99", "#99CCFF", "#DDAAFF",
          "#880000", "#880000", "#000088", "#000088",
          "#444444", "#444444", "#444444" ];


        let roomElement = document.getElementById("roomEntity");
        for (let i = 0; i < 14; i++)
        {
            let room = this.rainbowQuest.roomArray[i];
            let baseColor = roomColorArray[i];

            let roomEntity = document.createElement("a-entity");
            roomEntity.setAttribute("id", "room" + room.id);
            roomEntity.setAttribute("position", {x: room.x + room.w/2, y: 0, z: room.y + room.h/2});
            this.el.appendChild(roomEntity);

            let roomFloor = document.createElement("a-entity");
            roomFloor.setAttribute("geometry", 
              { primitive: "box", width: room.w, height: 0.04, depth: room.h } );
            roomFloor.setAttribute("material", "color", baseColor);
            roomFloor.classList.add("navMesh"); // enable teleporting here
            roomFloor.setAttribute("raycaster-target", "glowOnHover", "false");
            roomEntity.appendChild(roomFloor);

            // special code for each room type...
        }





        // minimap ------------------------------------------

        // will also need to store visited data and update only on cell entry, to minimize texture re-upload to GPU
        // NOT lots of little planes, the drawcalls would be AWFUL and LAAAAAAAAG
        this.canvas = document.getElementById("minimapCanvas");
        this.minimapContext = this.canvas.getContext("2d");
        this.minimapPlane = document.getElementById("minimapPlane");

        this.rainbowQuest.drawMap(this.minimapContext);

        let material = this.minimapPlane.getObject3D('mesh').material;
        material.map.needsUpdate = true;

        this.minimapMarker = document.getElementById("minimapMarker");
        this.minimapMarker.object3D.position.set(1,0,0);
        this.player = document.getElementById("player");

        /*
        // TODO: minimap graphics
        let picArray = [   
            " ", "❤️", "🔥", "☀️", "🍀", "💧", "🌑",
            "🌋", "🌋", "❄️", "❄️", "💀", "💀", "💀", ];
        */

        this.el.setAttribute("position", "40 0 30");
        this.el.setAttribute("rotation", "0 180 0");
        // mini model for inspection
        // this.el.setAttribute("scale", "0.1 0.1 0.1");
        // life size
        this.el.setAttribute("scale", "2 2 2");
        
        this.controllerData = document.querySelector("#controller-data").components["controller-listener"];

        // try to reduce attribute calls to reduce context lost?
        this.euler = new THREE.Euler(0,0,0, "XYZ");

        this.cameraDirection = new THREE.Vector3();
        this.cameraAngle = 0;

    },

    tick: function()
    {
        // calculate direction based on camera look direction, not just player rotation
        this.el.sceneEl.camera.getWorldDirection(this.cameraDirection);
        this.cameraAngle = Math.atan2(this.cameraDirection.z, this.cameraDirection.x);
        this.euler.z = -this.cameraAngle + Math.PI;
        this.minimapMarker.object3D.children[0].setRotationFromEuler(this.euler);

        // less accurate...
        // let rot = this.player.getAttribute("rotation").y;
        // this.minimapMarker.setAttribute("rotation", {x: 0, y: 0, z: rot});

    }
});


</script>

<a-scene stats xenvironment="preset: default;" background="color: black;">
        
    <a-assets>
        <img id="gradient" src="images/gradient-fade.png" />
        <canvas id="minimapCanvas" width="512" height="512"></canvas>
        <img id="minimapArrow" src="images/circle-A.png" />
    </a-assets>

    <!--
    <a-sky 
        color = "#8888FF">
    </a-sky>
    -->

    <a-entity 
        id="player" 
        position="0 1.6 40" 
        player-move="controllerListenerId: #controller-data;
                     navigationMeshClass: navMesh;">
        
        <a-camera position="0 0 0"></a-camera>
    
        <a-entity 
            id="controller-data" 
            controller-listener="leftControllerId:  #left-controller; 
                                 rightControllerId: #right-controller;">
        </a-entity>

        <a-entity 
            id="left-controller"
            oculus-touch-controls="hand: left">

            <a-plane id="minimapPlane" 
                     scale = "0.2 0.2 0.2"
                     material="shader: flat; src: #minimapCanvas;" 
                     position="0.0 -0.0 0.15" 
                     rotation="-30 0 0">
                <a-plane id="minimapBacking"
                         scale="1.01 1.01 1"
                         position="0 0 -0.001"
                         material="shader: flat; color: #8800FF; side: double;">
                </a-plane>
                <a-plane id="minimapMarker"
                         scale="0.025 0.025 0.025"
                         position="0 0 0.005"
                         rotation="0 0 90"
                         material="src: #minimapArrow;">
                </a-plane>
            </a-plane>

        </a-entity>

        <a-entity
            id="right-controller"
            oculus-touch-controls="hand: right"
            raycaster="objects: .raycaster-target, .environmentGround, .test;"
            raycaster-extras="controllerListenerId: #controller-data; 
                              beamImageSrc: #gradient; beamLength: 0.5;">
        </a-entity>

    </a-entity>

    <a-entity rainbow-quest>
        <a-entity id="pathEntity" raycaster-target="glowOnHover: false;" class="navMesh"></a-entity>
        <a-entity id="wallEntity" raycaster-target="glowOnHover: false;" ></a-entity>
        <a-entity id="roomEntity"></a-entity>
        <a-entity id="solidEntity"></a-entity>
    </a-entity>    


</a-scene>
</body>

</html>