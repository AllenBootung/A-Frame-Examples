<!DOCTYPE html>
<html>

<head>
    <title>Rainbow Quest (work in progress)</title>
    <meta name="description" content="Rainbow Quest (work in progress)">
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="js/aframe-environment-component.js"></script>
    <script src="js/controller-listener.js"></script>
    <script src="js/player-move.js"></script>
    <script src="js/raycaster-extras.js"></script>
    <script src="js/rainbow-quest.js"></script>
</head>

<body>

<script>
// if raycaster is pointing at this object, press trigger to change color
AFRAME.registerComponent("rainbow-quest", {
    init: function () 
    {

        // TODO: random WebGL context lost. Need to continue from this point...

        // test with: document.querySelector("a-scene").renderer.forceContextLoss();
        const renderer = this.el.sceneEl.renderer;
        renderer.getContext().canvas.addEventListener("webglcontextlost", function(event) {
            event.preventDefault();
            console.log("goodbye context");
            renderer.forceContextRestore();
        }, false);

        renderer.getContext().canvas.addEventListener("webglcontextrestored", function(event) {
            console.log("welcome back context");
        }, false);

        this.rainbowQuest = new RainbowQuest();        
        this.rainbowQuest.generateDungeon();

        let test = this.rainbowQuest.getCellWithType();
        while (test == null)
        {
            console.log("Unsolvable dungeon created, restarting...");
            this.rainbowQuest.reset();
            this.rainbowQuest.generateDungeon();
            test = this.rainbowQuest.getCellWithType();
        }




        // merge geometries to reduce number of draw calls and save FPS
        // (x,y,z): min corner of the object
       
        // floor tiles
        function createPlaneGeom(x,y,z, w,h,d)
        {
            let planeGeom = new THREE.PlaneGeometry(w, d);
            planeGeom.rotateX(-Math.PI/2);
            planeGeom.translate(x + w/2, y + h/2, z + d/2);
            return planeGeom;
        }

        function createHorizWallPlaneGeom(x,y,z, w,h)
        {
            let planeGeom = new THREE.PlaneGeometry(w, h);
            planeGeom.translate(x + w/2, y + h/2, z);
            return planeGeom;
        }

        function createVertWallPlaneGeom(x,y,z, w,h)
        {
            let planeGeom = new THREE.PlaneGeometry(w, h);
            planeGeom.rotateY(-Math.PI/2);
            planeGeom.translate(x, y + h/2, z + w/2);
            return planeGeom;
        }

        // walls

        let wallGeomArray = [];
        let wallHeight = 1;
        let wallThick = 0.02;

        for (let i = 0; i < this.rainbowQuest.numCellHoriz; i++)
            for (let j = 0; j < this.rainbowQuest.numCellVert+1; j++)
                if (this.rainbowQuest.horizWallArray[i][j].visible)
                    wallGeomArray.push( createHorizWallPlaneGeom(i, 0, j, 1, wallHeight) );

        for (let i = 0; i < this.rainbowQuest.numCellHoriz+1; i++)
            for (let j = 0; j < this.rainbowQuest.numCellVert; j++)
                if (this.rainbowQuest.vertWallArray[i][j].visible)
                    wallGeomArray.push( createVertWallPlaneGeom(i, 0, j, 1, wallHeight) );

        let wallGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries( wallGeomArray );

        // trying to clear up memory
        for (let n = 0; n < wallGeomArray.length; n++)
            wallGeomArray[n].dispose();
        
        wallGeomArray = [];

        let loader = new THREE.TextureLoader();
        let wallDiffuse = loader.load("images/stone-wall-diffuse-256.jpg");
        wallDiffuse.repeat.set(2,3);
        wallDiffuse.wrapS = THREE.RepeatWrapping;
        wallDiffuse.wrapT = THREE.RepeatWrapping;
        let wallNormal = loader.load("images/stone-wall-normal-256.jpg");
        wallNormal.repeat.set(2,3);
        wallNormal.wrapS = THREE.RepeatWrapping;
        wallNormal.wrapT = THREE.RepeatWrapping;
        let wallMaterial = new THREE.MeshStandardMaterial({color: "#FFFFFF", map:wallDiffuse, normalMap:wallNormal, side:THREE.DoubleSide});

        let wall = new THREE.Mesh(wallGeometry, wallMaterial);
        let wallElement = document.getElementById("wallEntity");
        wallElement.setObject3D( "mesh", wall );

        // path region tiles

        let pathGeomArray = [];

        for (let i = 0; i < this.rainbowQuest.numCellHoriz; i++)
            for (let j = 0; j < this.rainbowQuest.numCellVert; j++)
            {
                let cell = this.rainbowQuest.cellArray[i][j];
                
                // create a "tile" at the bottom of this location
                if (cell.type == Cell.PATH) 
                    pathGeomArray.push( createPlaneGeom(i, 0, j, 1, 0, 1) );
            }

        if (pathGeomArray.length == 0)
            console.log("error: can't merge an array with length 0")

        let pathGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries( pathGeomArray );

        // trying to clear up memory
        for (let n = 0; n < pathGeomArray.length; n++)
            pathGeomArray[n].dispose();

        pathGeomArray = [];

        let pathDiffuse = loader.load("images/floor-diffuse-256.jpg");
        let pathMaterial = new THREE.MeshStandardMaterial({color: "#FFFFFF", map:pathDiffuse});
        let path = new THREE.Mesh(pathGeometry, pathMaterial);
        let pathElement = document.getElementById("pathEntity");
        pathElement.setObject3D( "mesh", path );

        // ceiling

        let ceilingGeo = new THREE.PlaneGeometry(40, 30);
        ceilingGeo.rotateX(Math.PI/2);
        ceilingGeo.translate(20, 1, 15);
        let ceilingTex = loader.load("images/floor-diffuse-256.jpg");
        ceilingTex.repeat.set(160,120);
        ceilingTex.wrapS = THREE.RepeatWrapping;
        ceilingTex.wrapT = THREE.RepeatWrapping;
        let ceilingMat = new THREE.MeshStandardMaterial({color: "#AAAAAA", map:ceilingTex});
        let ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
        let ceilingElement = document.getElementById("ceilingEntity");
        ceilingElement.setObject3D( "mesh", ceiling );

        // rooms

        // start
        // orb 1 2 3 4 5 6
        // fire fire ice ice nega nega nega
        let roomColorArray = [
          "#CCCCCC", 
          "#FFCCCC", "#FFCC88", "#FFFF88", "#99FF99", "#99CCFF", "#DDAAFF",
          "#880000", "#880000", "#000088", "#000088",
          "#444444", "#444444", "#444444" ];


        let roomElement = document.getElementById("roomEntity");
        for (let i = 0; i < 14; i++)
        {
            let room = this.rainbowQuest.roomArray[i];
            let baseColor = roomColorArray[i];

            let roomEntity = document.createElement("a-entity");
            roomEntity.setAttribute("id", "room" + room.id);
            roomEntity.setAttribute("position", {x: room.x + room.w/2, y: 0, z: room.y + room.h/2});
            this.el.appendChild(roomEntity);

            let roomFloor = document.createElement("a-entity");
            roomFloor.setAttribute("geometry", 
              { primitive: "plane", width: room.w, height: room.h } );
            roomFloor.setAttribute("rotation", "-90 0 0");
            roomFloor.setAttribute("material", "color", baseColor);
            roomFloor.classList.add("navMesh"); // enable teleporting here
            roomFloor.setAttribute("raycaster-target", "glowOnHover", "false");
            roomEntity.appendChild(roomFloor);

            // TODO: add special code for each room type...
        }

        // minimap ------------------------------------------

        this.canvas = document.getElementById("minimapCanvas");
        this.minimapContext = this.canvas.getContext("2d");
        this.minimapPlane = document.getElementById("minimapPlane");

        this.rainbowQuest.drawMap(this.minimapContext);

        let material = this.minimapPlane.getObject3D('mesh').material;
        material.map.needsUpdate = true;

        this.minimapMarker = document.getElementById("minimapMarker");
        this.minimapMarker.object3D.position.set(1,0,0);
        this.player = document.getElementById("player");

        /*
        // TODO: minimap graphics
        let picArray = [   
            " ", "❤️", "🔥", "☀️", "🍀", "💧", "🌑",
            "🌋", "🌋", "❄️", "❄️", "💀", "💀", "💀", ];
        */

        this.el.setAttribute("position", "80 0.05 60");
        this.el.setAttribute("rotation", "0 180 0");
        // mini model for inspection
        // this.el.setAttribute("scale", "0.1 0.1 0.1");
        // life size
        this.el.setAttribute("scale", "4 4 4");
        
        this.controllerData = document.querySelector("#controller-data").components["controller-listener"];

        // try to reduce attribute calls to reduce context lost?
        this.pos = new THREE.Vector3();
        this.euler = new THREE.Euler(0,0,0, "XYZ");

        this.cameraDirection = new THREE.Vector3();
        this.cameraAngle = 0;

        this.clock = new THREE.Clock();
        this.markerScale = 1;
    },

    tick: function()
    {
        // calculate direction based on camera look direction, not just player rotation
        this.el.sceneEl.camera.getWorldDirection(this.cameraDirection);
        this.cameraAngle = Math.atan2(this.cameraDirection.z, this.cameraDirection.x);
        this.euler.z = -this.cameraAngle + Math.PI;
        this.minimapMarker.object3D.children[0].setRotationFromEuler(this.euler);
        // less accurate...
        // let rot = this.player.getAttribute("rotation").y;
        // this.minimapMarker.setAttribute("rotation", {x: 0, y: 0, z: rot});

        this.pos.copy( this.player.object3D.position );
        this.minimapMarker.object3D.position.set(this.pos.x / 160, -this.pos.z / 160 - 0.5/4, 0.005);
        // TODO: marker invisible if out of bounds

        this.clock.getDelta();
        this.markerScale = 0.025 * (1 + 0.2 * Math.sin(8 * this.clock.elapsedTime));
        this.minimapMarker.object3D.scale.set(this.markerScale, this.markerScale, 1);

    }
});


</script>

<a-scene xstats 
 environment="preset: starry; fog: 0;  flatShading: false; ground: flat; groundTexture: walkernoise; groundColor: #1B0000; groundColor2: #331B00; grid: none"
 background="color: black;">
        
    <a-assets>
        <img id="gradient" src="images/gradient-fade.png" />
        <canvas id="minimapCanvas" width="512" height="512"></canvas>
        <img id="minimapArrow" src="images/minimapMarker.png" />
    </a-assets>

    <!-- Default lights: one directional light from top left, one small ambient light.
         Adding a light manually removes the default lighting setup.  -->
        <a-entity 
            light="type: ambient; color: #222222;">
        </a-entity>
        
    <a-entity 
        id="player" 
        position="0 0 80" 
        player-move="controllerListenerId: #controller-data;
                     navigationMeshClass: navMesh;">
        
        <a-camera position="0 1.6 0">
             <a-entity light="type: point; color: #FFFFFF; distance: 20;"></a-entity>
        </a-camera>
        

        <a-entity 
            id="controller-data" 
            controller-listener="leftControllerId:  #left-controller; 
                                 rightControllerId: #right-controller;">
        </a-entity>

        <a-entity 
            id="left-controller"
            oculus-touch-controls="hand: left">

            <a-plane id="minimapPlane" 
                     scale = "0.2 0.2 0.2"
                     material="shader: flat; src: #minimapCanvas;" 
                     position="0.0 -0.0 0.15" 
                     rotation="-30 0 0">

                <a-plane id="minimapBacking"
                         scale="1.1 1.1 1"
                         position="0 0 -0.001"
                         material="shader: flat; color: gray; side: double;">
                </a-plane>
                
                <a-plane id="minimapMarker"
                         scale="0.025 0.025 0.025"
                         position="0 0 0.005"
                         rotation="0 0 90"
                         material="src: #minimapArrow; transparent: true; color: yellow;">
                </a-plane>
            
            </a-plane>

        </a-entity>

        <a-entity
            id="right-controller"
            oculus-touch-controls="hand: right"
            raycaster="objects: .raycaster-target, .environmentGround;"
            raycaster-extras="controllerListenerId: #controller-data; 
                              beamImageSrc: #gradient; beamLength: 0.5;">
        </a-entity>

    </a-entity>

    <a-entity rainbow-quest>

        <a-entity id="pathEntity" raycaster-target="glowOnHover: false;" class="navMesh"></a-entity>
        <a-entity id="wallEntity" raycaster-target="glowOnHover: false;" ></a-entity>
        <a-entity id="ceilingEntity"></a-entity>
                
        <a-entity id="roomEntity"></a-entity>
    
    </a-entity>    


</a-scene>
</body>

</html>